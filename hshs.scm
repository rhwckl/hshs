(use srfi-13)
(define (hshs src . a)
  (define op-data
    `((" " 10 assoc-left . ,(lambda (l r) (l r)))
      ("^" 8 assoc-left . ,(lambda (l r) (expt l r)))
      ("*" 7 assoc-left . ,(lambda (l r) (* l r)))
      ("+" 6 assoc-left . ,(lambda (l r) (+ l r)))
      ("-" 6 assoc-left . ,(lambda (l r) (- l r)))
      (":" 5 assoc-right . ,(lambda (l r) (cons l r)))
      ("$" 0 assoc-right . ,(lambda (f x) (f x)))))
  (define (get-op o) (if (char? o) (assoc (string o) op-data) (assoc o op-data)))

  (define (string->tree s)
    (define (sop i) (get-op (string-ref s i)))
    (define (op-order lo ro lf rf)
      (cond ((< (cadr lo) (cadr ro)) rf)
            ((> (cadr lo) (cadr ro)) lf)
            ((not (eq? (caddr lo) (caddr ro))) #f)
            ((eq? (caddr lo) 'assoc-left) lf)
            (else rf)))
    (let ((len (string-length s)))
      (define after-bracket-index
        (lambda (i n)
          (cond ((= n 0) i)
                ((= i len) #f)
                ((char=? (string-ref s i) #\() (after-bracket-index (+ i 1) (+ n 1)))
                ((char=? (string-ref s i) #\)) (after-bracket-index (+ i 1) (- n 1)))
                (else (after-bracket-index (+ i 1) n)))))
      (define (call-op? i l)
        (cond ((= i len) #f)
              ((char=? (string-ref s i) #\)) #f)
              ((and (not (sop i)) l) #t)
              (else #f)))
      (define (string->tree-aux i l o)
        (let ((f (lambda (i l o)
                   (let ((ret (string->tree-aux (+ i 1) #f (sop i))))
                     (string->tree-aux (car ret) (cons (sop i) (cons l (cdr ret))) o)))))
          (cond ((= i len) (cons len l))
                ((char=? (string-ref s i) #\() (string->tree-aux (after-bracket-index (+ i 1) 1) (cdr (string->tree-aux (+ i 1) #f #f)) o))
                ((char=? (string-ref s i) #\)) (cons len l))
                ((char=? (string-ref s i) #\space)
                  (cond ((not (call-op? (+ i 1) l)) (string->tree-aux (+ i 1) l o))
                        ((not o) (f i l #f))
                        (else (op-order o (get-op #\space) (cons i l) (f i l o)))))
                ((char=? (string-ref s i) #\[) (string->tree-aux (+ i 2) "[]" o))
                ((not (sop i)) (string->tree-aux (+ i 1) (string (string-ref s i)) o))
                ((not o) (f i l #f))
                (else (op-order o (sop i) (cons i l) (f i l o)))))) ;(Just p)
      (cdr (string->tree-aux 0 #f #f))))

  (define (tree->value t m)
    (cond ((not (pair? t)) (cond ((string->number t) (string->number t))
                                 ((string=? t "[]") '())
                                 (else (if m (let ((x (cdr (assoc t m)))) (if (promise? x) (force x) x)) t))))
          (else ((cdddar t) (tree->value (cadr t) m) (tree->value (cddr t) m)))))
  (define (hshs-aux s i arg)
    (define (pat-match i a)
      (define (pat-match-aux t a)
        (cond ((not (pair? t)) (let ((x (tree->value t #f)))
                                 (cond ((string? x) (list (cons t a)))
                                       ((eq? x a) '())
                                       (else #f))))
              ((not (pair? a)) #f)
              ((eq? (car t) (get-op #\:)) (let ((l (pat-match-aux (cadr t) (car a))) (r (pat-match-aux (cddr t) (cdr a))))
                                            (if (and l r) (append l r) #f)))
              (else #f)))
      (let ((n (+ 1 (string-index s #\space (+ i 1)))))
        (cons n (pat-match-aux (string->tree (string-drop (string-take s (- n 1)) i)) a))))

    (if (char=? (string-ref s i) #\=)
        (tree->value (string->tree (string-drop (string-take s (string-index s #\newline (+ i 1))) (+ i 1)))
                     (append (fold-left (lambda (l r) (if (null? (cdr r)) l (append l (cdr r)))) '() arg)
                             (list (cons (string-take s 1) (delay (hshs s))))))
        (lambda (a)
          (let* ((ret (pat-match i a)) (n (car ret)) (x (cdr ret)))
            (if (not x)
              (letrec ((check (lambda (i arg*)
                                (cond
                                  ((null? arg*) (list i))
                                  (else
                                    ((lambda (a)
                                      (let* ((ret (pat-match i a)) (n (car ret)) (x (cdr ret)))
                                        (if x (cons (cons a x) (check n (cdr arg*)))
                                              (check (+ 3 (string-index s #\newline n)) (reverse arg)))))
                                     (caar arg*)))))))
                (let ((ret (check (+ 3 (string-index s #\newline n)) (reverse arg))))
                  (if ret ((hshs-aux s (last ret) (reverse (drop-right ret 1))) a) #f)))
              (hshs-aux s n (cons (cons a x) arg)))))))
  (letrec ((loop (lambda (r a) (if (null? a) r (loop (r (car a)) (cdr a))))))
    (loop (hshs-aux src 2 '()) a)))

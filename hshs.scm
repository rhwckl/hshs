(use srfi-13)
(define (hshs src . a)
  (define op-data
    '((" " 10 . assoc-left)
      ("^" 8 . assoc-left)
      ("*" 7 . assoc-left)
      ("+" 6 . assoc-left) ("-" 6 . assoc-left)
      ))
  (define (get-op o) (if (char? o) (assoc (string o) op-data) (assoc o op-data)))

  (define (string->tree s)
    (define (sop i) (get-op (string-ref s i)))
    (define (op-order lo ro lf rf)
      (cond ((< (cadr lo) (cadr ro)) rf)
            ((> (cadr lo) (cadr ro)) lf)
            ((not (eq? (cddr lo) (cddr ro))) #f)
            ((eq? (cddr lo) 'assoc-left) lf)
            (else rf)))

    (let ((len (string-length s)))
      (define after-bracket-index (lambda (i n)
        (cond ((= n 0) i)
              ((= i len) #f)
              ((char=? (string-ref s i) #\() (after-bracket-index (+ i 1) (+ n 1)))
              ((char=? (string-ref s i) #\)) (after-bracket-index (+ i 1) (- n 1)))
              (else (after-bracket-index (+ i 1) n)))))

      (define (call-op? i l)
        (cond ((= i len) #f)
              ((char=? (string-ref s i) #\)) #f)
              ((and (not (sop i)) l) #t)
              (else #f)))

      (define (string->tree-aux i l o)
        (let ((f (lambda (i l o)
                   (define ret (string->tree-aux (+ i 1) #f (sop i)))
                   (string->tree-aux (car ret) (cons (sop i) (cons l (cdr ret))) o))))
          (cond
            ((= i len) (cons len l))
            ((char=? (string-ref s i) #\() (string->tree-aux (after-bracket-index (+ i 1) 1)
                                                             (cdr (string->tree-aux (+ i 1) #f #f)) o))
            ((char=? (string-ref s i) #\)) (cons len l))
            ((char=? (string-ref s i) #\space)
              (cond ((not (call-op? (+ i 1) l)) (string->tree-aux (+ i 1) l o))
                    ((not o) (f i l #f))
                    (else (op-order o (get-op #\space) (cons i l) (f i l o)))))
            ((not (sop i)) (string->tree-aux (+ i 1) (string (string-ref s i)) o))
            ((not o) (f i l #f))
            (else (op-order o (sop i) (cons i l) (f i l o))))))
      (cdr (string->tree-aux 0 #f #f))))

  (define (tree->value t m)
    (cond ((not (pair? t)) (if (string->number t) (string->number t) (let ((x (cdr (assoc t m)))) (if (promise? x) (force x) x))))
          ((eq? (car t) (get-op #\space)) ((tree->value (cadr t) m) (tree->value (cddr t) m)))
          ((eq? (car t) (get-op #\^)) (expt (tree->value (cadr t) m) (tree->value (cddr t) m)))
          ((eq? (car t) (get-op #\*)) (* (tree->value (cadr t) m) (tree->value (cddr t) m)))
          ((eq? (car t) (get-op #\+)) (+ (tree->value (cadr t) m) (tree->value (cddr t) m)))
          ((eq? (car t) (get-op #\-)) (- (tree->value (cadr t) m) (tree->value (cddr t) m)))
          (else #f)))

  (define (hshs-aux s i arg)
    (define (pat-match i a)
      (let ((x (digit->integer (string-ref s i))))
        (cond ((eq? x a) #t)
              (x #f)
              (else (cons (string (string-ref s i)) a)))))

    (if (char=? (string-ref s i) #\=)
        (tree->value (string->tree (string-drop (string-take s (string-index s #\newline (+ i 1))) (+ i 1)))
                     (append (filter pair? arg) (list (cons (string-take s 1) (delay (hshs s))))))
        (lambda (a) (let ((x (pat-match i a)))
          (case x ((#t) (hshs-aux s (+ i 2) (cons a arg)))
                  ((#f) (letrec ((check (lambda (i arg*)
                                          (cond
                                            ((not i) #f)
                                            ((null? arg*) (cons (+ i 3) '()))
                                            (else
                                              ((lambda (a)
                                                (let ((ret (pat-match (+ i 3) a)))
                                                  (case ret ((#t) (cons a (check (+ i 2) (cdr arg*))))
                                                            ((#f) (check (string-index s #\newline (+ i 1)) (reverse arg)))
                                                            (else (cons ret (check (+ i 2) (cdr arg*)))))))
                                               (if (pair? (car arg*))
                                                   (cdar arg*)
                                                   (car arg*))))))))
                          (let ((ret (check (string-index s #\newline (+ i 1)) (reverse arg))))
                            (if ret ((hshs-aux s (last ret) (reverse (drop-right ret 1))) a) #f))))
                  (else (hshs-aux s (+ i 2) (cons x arg))))))))
  (letrec ((loop (lambda (r a) (if (null? a) r (loop (r (car a)) (cdr a))))))
    (loop (hshs-aux src 2 '()) a)))
